input {
  file {
    path => "/var/log/logstash/*.log" # Chemin vers les fichiers de logs
    start_position => "beginning"    # Lire depuis le début pour les nouveaux fichiers
    sincedb_path => "/dev/null"      # Désactive le suivi de progression pour le développement
    codec => plain                   # Pas de codec par défaut
  }
}

filter {
  # Détection automatique des logs Django au format JSON
  if [message] =~ "^{.*}$" { # Vérifie si le message ressemble à un JSON
    json {
      source => "message"
    }
    mutate {
      add_field => { "app_name" => "django" }
    }
  }
  
  # Traitement spécifique des logs pgAdmin4
  else if [path] =~ "pgadmin4.log$" { # Vérifie si le fichier est pgadmin4.log
    grok {
      match => { 
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:log_level}\] \(%{DATA:process_id}\): %{GREEDYDATA:log_message}" 
      }
    }
    date {
      match => ["timestamp", "ISO8601"]
    }
    mutate {
      add_field => { "app_name" => "pgadmin4" }
    }
  }
  
  # Cas générique pour les autres logs non pris en charge
  else {
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:log_level} %{GREEDYDATA:log_message}" }
    }
    date {
      match => ["timestamp", "ISO8601"]
    }
    mutate {
      add_field => { "app_name" => "generic" }
    }
  }
}

output {
  elasticsearch {
    hosts => ["https://es:9200"]     # Adresse d'Elasticsearch
    index => "%{app_name}-logs-%{+yyyy.MM.dd}" # Index basé sur l'application et la date
    user => "elastic"               # Identifiants Elasticsearch
    password => "${ELASTIC_PASSWORD}"
    cacert => "certs/ca/ca.crt"
  }
  stdout {
    codec => rubydebug # Affiche les logs dans la console pour déboguer
  }
}
